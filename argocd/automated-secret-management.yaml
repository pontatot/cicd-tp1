---
# Option 3: Automated Image Pull Secret Management
# This approach uses a CronJob to automatically create image pull secrets in namespaces

# ClusterRole for secret management
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: secret-manager
rules:
- apiGroups: [""]
  resources: ["secrets", "serviceaccounts", "configmaps"]
  verbs: ["get", "list", "create", "update", "patch", "delete"]
- apiGroups: [""]
  resources: ["namespaces"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list"]

---
# ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: secret-manager
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: secret-manager
subjects:
- kind: ServiceAccount
  name: secret-manager
  namespace: argocd

---
# ServiceAccount for secret management
apiVersion: v1
kind: ServiceAccount
metadata:
  name: secret-manager
  namespace: argocd

---
# CronJob to watch for new namespaces and create secrets
apiVersion: batch/v1
kind: CronJob
metadata:
  name: namespace-secret-manager
  namespace: argocd
spec:
  schedule: "*/2 * * * *"  # Run every 2 minutes
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: secret-manager
          containers:
          - name: secret-manager
            image: bitnami/kubectl:latest
            command:
            - /bin/bash
            - -c
            - |
              set -e  # Exit on any error
              
              echo "Checking for namespaces that need image pull secrets..."
              
              # Get GitHub credentials
              USERNAME=$(kubectl get secret github-credentials -n argocd -o jsonpath='{.data.username}' | base64 -d)
              TOKEN=$(kubectl get secret github-credentials -n argocd -o jsonpath='{.data.token}' | base64 -d)
              
              if [ -z "$TOKEN" ]; then
                echo "ERROR: GitHub token not found in secret"
                exit 1
              fi
              
              # Find namespaces that match our pattern and don't have the secret
              NAMESPACES=$(kubectl get namespaces -o name | grep -E "(city-api-production|city-api-pr-)" | sed 's/namespace\///' || true)
              
              if [ -z "$NAMESPACES" ]; then
                echo "No city-api namespaces found"
                exit 0
              fi
              
              for NS in $NAMESPACES; do
                echo "Checking namespace: $NS"
                
                # Check if secret already exists
                if kubectl get secret registry-secret -n "$NS" >/dev/null 2>&1; then
                  echo "Secret already exists in $NS"
                  continue
                fi
                
                echo "Creating registry-secret in namespace: $NS"
                
                # Create the secret
                kubectl create secret docker-registry registry-secret \
                  --docker-server=ghcr.io \
                  --docker-username="$USERNAME" \
                  --docker-password="$TOKEN" \
                  --namespace="$NS" \
                  --dry-run=client -o yaml | kubectl apply -f -
                
                # Patch the default service account to use the secret
                kubectl patch serviceaccount default -n "$NS" -p '{"imagePullSecrets":[{"name":"registry-secret"}]}'
                
                echo "Secret created and service account patched in $NS"
              done
              
              echo "Secret management complete"
          restartPolicy: OnFailure